/*
 * RenderPass.h
 *
 *  Created on: Mar 26, 2011
 *      Author: tbabb
 * 
 * Current user responsibilities:
 *   - Don't ask this class to render to more than GL_MAX_COLOR_ATTACHMENTS color outputs
 *   - Don't try to use a texture ID'd by 0 (i.e. the result of querying for an output that is not enabled in this pass)
 *   - Delete any and all textures generated by this render pass when you are done with them; they are not released by the destructor.
 *   - Enable at least one output of any kind (i.e. n_color_outputs > 0 or depth_output is true)
 * 
 * To use: Construct and add to a GLWindow. Place renderable scene objects into RenderPass.scene_objs
 * 
 * Meanings:
 *   - w, h: width and height, in pixels, of the rendered pass
 *   - n_color_outputs: Shall the render pass enable multiple color render targets? If so, how many?
 *   - datatype: Internal format of color data. e.g. GL_RGBA, GL_LUMINANCE, GL_RGB16, GL_RGBA32F_ARB, GL_RGBA16F_ARB, etc.
 *   - data_types: An array of "internal format" data types, as above, corresponding to each output. must be of length n_color_outputs.
 *   - depth_output: Shall the render pass output depth information to a texture? Depth_test must also be enabled for this to work.
 *   - depth_test: Shall the render pass perform a depth test while rendering the scene? Will cause internal buffer memory to be allocated for depth testing.
 */

//TODO: manage uint texture ID problem
//TODO: mipmaps?
//TODO: setSize()
//TODO: build() should check what it has to release, in case we have reset the image size. We don't want
//      to re-allocate the whole renderbuffer, especially without releasing the prev. one
//TODO: Link setSize() to GLWindow
//TODO: it is not good to copy these things because they hold external resources. kill the copy constructor, or allocate shared storage with overridden copy cons.

//TODO: Abstract the final pass into a RenderPass()?
//TODO: Cubemap render pass abstraction

//TEST: is it valid to have a depth output with no depth test?
//TEST: multiple render targets

#ifndef RENDERPASS_H_
#define RENDERPASS_H_

#include <OpenGL/gl.h>
#include <vector>

#include <geomc/linalg/Vec.h>
#include "Camera.h"
#include "Drawable.h"
#include "Texture.h"

class RenderPass {
public:
    std::vector<Drawable*> scene_objs;
    Camera *cam;
    
    RenderPass(Camera *cam);
    RenderPass(Camera *cam, int w, int h, int n_color_outputs, int *data_types, bool depth_output, bool depthTest);
    RenderPass(Camera *cam, int w, int h, int data_type, bool depth_output, bool depthTest);
    virtual ~RenderPass();
    
    virtual void build();  //will return with the framebuffer actively bound 
    virtual void render(); //to be called in a valid opengl context
    Texture getOutputTexture(int output); //accepts GL_DEPTH_ATTACHMENT or GL_COLOR_ATTACHMENTi. Returns 0 if no such attachment is in use.
    int  getNumColorOutputs(); //number of color outputs. may be 0
    bool hasOutput(int output); //does this pass render to the named output (i.e. GL_{DEPTH,COLOR}_ATTACHMENTx_EXT)?
    void setSize(int w, int h); //currently does nothing
    void setClearColor(Vec4d color);
    
protected:
    
    int     _w;
    int     _h;
    GLuint  _fbo_id;           //id of the framebuffer object (contains all sub-passes, i.e. depth/color*)
    int     _n_color_outputs;  //number of color outputs; may be 0
    std::vector<Texture> _outputs;  //output color pass textures
    Texture _depth_output_tex; //output depth texture if we are outputting
    GLuint  _depth_output_buf; //ID of depth rederbuffer, or 0 if outputting
    bool    _do_depthtest;     //do depth test?
    bool    _do_depth_output;  //do we render depth to an unreadable buffer, or a usable texture?
    bool    _is_built;
    Vec4d   _clearColor;
    
    static GLuint attachmentIds16[16];
    
};

#endif /* RENDERPASS_H_ */
